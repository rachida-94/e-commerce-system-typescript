I started this TypeScript project by building a Product class that defined all the core properties I wanted to work with: title, price, discountPercentage, rating, description, category, and image. I included two methods—displayDetails() and getPriceWithDiscount() to format and calculate product information. Once that foundation was set, I created two utility modules: one for calculating discounts (calculateDiscount()), which gives the dollar amount saved based on percentage, and another for calculating taxes (calculateTax()), which applies a default 4.75% tax or 3% for groceries based on category. To handle real data, I built an asynchronous API service using fetch() and try/catch, and wrote a custom error handler to gracefully respond to issues like image or category errors. In my main application file, I used map() to loop through the raw product list and filter() within a custom filterProductData() function to remove any unnecessary fields and align the structure with my class. After filtering, I created Product instances and calculated both discount and tax for each item. Since the calculateDiscount() function returned a formatted string like "$2.50", I needed to convert it into a usable number for calculations. To handle this, I applied a regular expression with replace(/[^0-9.]/g, "") to strip out everything except digits and decimal points, allowing me to safely parse it using parseFloat() before subtracting it from the original price. I made sure to log the output clearly with consistent formatting. During development, I ran into TypeScript issues such as dynamic key indexing errors and type mismatches when directly assigning API data to a Product[]. I fixed these using type assertions (key as keyof Product) and by working with any[] . One thing I discovered was that the code didn’t execute properly while still in TypeScript it only worked the way I wanted after compiling to JavaScript . Once compiled and tested , everything functioned as expected, and I was able to verify my logic across each module.
